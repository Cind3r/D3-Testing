<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ==========================================
         DOCUMENT METADATA & EXTERNAL LIBRARIES
    ========================================== -->
    <meta charset="UTF-8">
    <title>Datasaurus Dozen D3 Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- ==========================================
         CSS STYLES
    ========================================== -->
    <style>
    /* Base page styling */
    body { font-family: Arial, sans-serif; margin: 40px; background: #181a20; color: #e0e0e0; }
    h1 { text-align: center; color: #fafafa; }
    
    /* Chart container and visualization styling */
    .chart-container { display: flex; gap: 40px; justify-content: center; margin-bottom: 60px; }
    .chart { background: #23272f; border-radius: 8px; box-shadow: 0 2px 8px #111; padding: 20px; }
    .chart-title { text-align: center; margin-bottom: 10px; font-weight: bold; color: #fafafa; }
    .superposition { margin: 0 auto; width: 700px; }
    
    /* Form controls styling */
    label { color: #e0e0e0; }
    select { background: #23272f; color: #e0e0e0; border: 1px solid #444; border-radius: 4px; padding: 4px; }
    
    /* SVG axis and text styles */
    svg text, .tick text { fill: #e0e0e0 !important; }
    .domain, .tick line { stroke: #888 !important; }
    
    /* Legend box and text */
    .legend rect { stroke: #444; }
    .legend text { fill: #e0e0e0; }
    
    /* Navigation bar styling */
    .navbar {
        background: #23272f;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        padding: 1rem 2rem;
    }
    .navbar-brand {
        font-size: 1.5rem;
        font-weight: bold;
        color: #f8f8f8;
        margin-bottom: 0.5rem;
    }
    .accordion {
        width: 100%;
        background: none;
        border: none;
        color: #a3a3ff;
        font-size: 1.1rem;
        cursor: pointer;
        padding: 0.5rem 0;
        text-align: left;
        outline: none;
        transition: color 0.2s;
    }
    .accordion:hover {
        color: #ffd700;
    }
    .panel {
        display: none;
        flex-direction: column;
        gap: 1rem;
        margin-top: 0.5rem;
    }
    .panel.show {
        display: flex;
    }
    .panel a {
        color: #a3a3ff;
        text-decoration: none;
        font-size: 1.1rem;
        transition: color 0.2s;
    }
    </style>
</head>

<body>
    <!-- ==========================================
         NAVIGATION SECTION
    ========================================== -->
    <nav class="navbar">
        <div class="navbar-brand">D3 Assignment</div>
        <button class="accordion" id="menuToggle">Pages â–¼</button>
        <div class="panel" id="menuPanel">
            <!-- Links will be loaded here by JS -->
        </div>
    </nav>
    
    <!-- ==========================================
         PAGE HEADER & DESCRIPTION
    ========================================== -->
    <h1>Datasaurus Dozen: D3 Visualizations</h1>
    <p>
        All datasets in the Datasaurus Dozen have the same means, standard deviations, and correlations, but vastly different structures.
        Below, two visualization paradigms illustrate these differences: juxtaposition (side-by-side scatterplots) and superposition (overlaid bar chart).
    </p>

    <!-- ==========================================
         DATASET SELECTION CONTROLS
    ========================================== -->
    <div style="display: flex; justify-content: center; gap: 40px; margin-bottom: 30px;">
        <div>
            <label for="datasetA">Select Dataset A:</label>
            <select id="datasetA"></select>
        </div>
        <div>
            <label for="datasetB">Select Dataset B:</label>
            <select id="datasetB"></select>
        </div>
    </div>

    <!-- ==========================================
         SCATTERPLOT VISUALIZATIONS
    ========================================== -->
    <div class="chart-container">
        <div class="chart" id="scatter-A">
            <div class="chart-title" id="title-A">Scatterplot: </div>
            <svg width="300" height="300"></svg>
        </div>
        <div class="chart" id="scatter-B">
            <div class="chart-title" id="title-B">Scatterplot: </div>
            <svg width="300" height="300"></svg>
        </div>
    </div>

    <!-- ==========================================
         SUPERPOSITION BAR CHART & CONTROLS
    ========================================== -->
    <div style="display: flex; flex-direction: column; align-items: center; gap: 20px; margin-bottom: 40px;">
        <button id="toggle-negative-x" style="background: #23272f; color: #e0e0e0; border: 1px solid #444; border-radius: 4px; padding: 8px 16px; font-size: 15px; cursor: pointer; margin-bottom: 10px;">Change B Plot to Positive</button>
        <div class="chart superposition" id="bar-superposition">
            <div class="chart-title" id="title-superposition">Superposition: X Distribution</div>
            <svg width="700" height="300"></svg>
        </div>
    </div>

    <!-- ==========================================
         JAVASCRIPT: DATA PROCESSING & VISUALIZATION
    ========================================== -->
    <script>
    /* ==========================================
       DATA LOADING & INITIALIZATION
    ========================================== */
    d3.csv("data.csv").then(function(data) {
        // Find global min/max for x and y
        const globalX = d3.extent(data, d => +d.x);
        const globalY = d3.extent(data, d => +d.y);
        
        // Compute global max bin count for histogram y-axis
        const datasetNames = Array.from(new Set(data.map(d => d.dataset)));
        const bins = d3.bin().domain([0, 100]).thresholds(20);
        let globalMaxBinCount = 0;
        datasetNames.forEach(name => {
            const dataset = data.filter(d => d.dataset === name).map(d => +d.x);
            const binCounts = bins(dataset).map(bin => bin.length);
            const maxCount = d3.max(binCounts);
            if (maxCount > globalMaxBinCount) globalMaxBinCount = maxCount;
        });
        
        // Populate dropdown menus with dataset options
        datasetNames.forEach(name => {
            d3.select("#datasetA").append("option").attr("value", name).text(name);
            d3.select("#datasetB").append("option").attr("value", name).text(name);
        });
        
        // Set default selections
        d3.select("#datasetA").property("value", "dino");
        d3.select("#datasetB").property("value", "circle");

        /* ==========================================
           COLOR PALETTE CONFIGURATION
        ========================================== */
        const colors = ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999", "#1b9e77", "#d95f02", "#7570b3"];
        function getColor(idx) { return colors[idx % colors.length]; }

        /* ==========================================
           SCATTERPLOT DRAWING & ANIMATION FUNCTIONS
        ========================================== */
        function drawScatter(selector, dataset, color) {
            const svg = d3.select(selector + " svg");
            svg.selectAll("*").remove();
            const width = +svg.attr("width"), height = +svg.attr("height");
            const margin = {top: 20, right: 20, bottom: 30, left: 30};
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Use global axis limits
            const x = d3.scaleLinear()
                .domain(globalX).nice()
                .range([0, plotWidth]);
            const y = d3.scaleLinear()
                .domain(globalY).nice()
                .range([plotHeight, 0]);

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            // Axes
            g.append("g")
                .attr("transform", `translate(0,${plotHeight})`)
                .call(d3.axisBottom(x));
            g.append("g")
                .call(d3.axisLeft(y));

            // Points with sequential animation (one-by-one, faster)
            function animatePoints(points, i, onDone) {
                if (i >= dataset.length) { if (onDone) onDone(); return; }
                points.filter((d, idx) => idx === i)
                    .transition()
                    .duration(60)
                    .attr("r", 3)
                    .attr("opacity", 0.7);
                setTimeout(() => animatePoints(points, i+1, onDone), 10);
            }

            const circles = g.selectAll("circle")
                .data(dataset, (d,i) => i);
            circles.enter()
                .append("circle")
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .attr("r", 0)
                .attr("fill", color)
                .attr("opacity", 0)
                .call(function(points) { animatePoints(points, 0, window.scatterDoneCallback); });
        }

        /* ==========================================
           SUPERPOSITION BAR CHART FUNCTIONS
        ========================================== */
        // Toggle state for negative x plotting
        if (typeof window.plotBNegativeX === 'undefined') window.plotBNegativeX = true;

        // Draw animated superposition bar chart
    function drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB) {
            const svgBar = d3.select("#bar-superposition svg");
            svgBar.selectAll("*").remove();
            const widthBar = +svgBar.attr("width"), heightBar = +svgBar.attr("height");
            const marginBar = {top: 20, right: 20, bottom: 30, left: 40};
            const plotWidthBar = widthBar - marginBar.left - marginBar.right;
            const plotHeightBar = heightBar - marginBar.top - marginBar.bottom;

            // Bin x values with updated bin count
            const binsA = bins(datasetA.map(d => d.x));
            const binsB = bins(datasetB.map(d => d.x));

            const xBar = d3.scaleLinear()
                .domain([0, 100])
                .range([0, plotWidthBar]);
            let yBar, gBar, axisYPos;
            if (window.plotBNegativeX) {
                // Centered y-axis: range [-globalMaxBinCount, globalMaxBinCount]
                yBar = d3.scaleLinear()
                    .domain([-globalMaxBinCount, globalMaxBinCount])
                    .range([plotHeightBar, 0]);
                gBar = svgBar.append("g").attr("transform", `translate(${marginBar.left},${marginBar.top})`);
                // Centered x-axis
                axisYPos = yBar(0);
                gBar.append("g")
                    .attr("transform", `translate(0,${axisYPos})`)
                    .call(d3.axisBottom(xBar));
                gBar.append("g")
                    .call(d3.axisLeft(yBar));
            } else {
                // Bottom y-axis: range [0, globalMaxBinCount]
                yBar = d3.scaleLinear()
                    .domain([0, globalMaxBinCount])
                    .range([plotHeightBar, 0]);
                gBar = svgBar.append("g").attr("transform", `translate(${marginBar.left},${marginBar.top})`);
                // Bottom x-axis
                axisYPos = yBar(0);
                gBar.append("g")
                    .attr("transform", `translate(0,${axisYPos})`)
                    .call(d3.axisBottom(xBar));
                gBar.append("g")
                    .call(d3.axisLeft(yBar));
            }

            // Animate only the bars for the changed dataset
            // Animate old bars toward the centered x-axis (y=0)
            if (window.prevBinsA && window.prevColorA && window.changedA) {
                const oldBarsA = gBar.selectAll(".old-bar-A")
                    .data(window.prevBinsA)
                    .enter().append("rect")
                    .attr("class", "old-bar-A")
                    .attr("x", d => xBar(d.x0))
                    .attr("y", d => yBar(d.length))
                    .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                    .attr("height", d => yBar(0) - yBar(d.length))
                    .attr("fill", window.prevColorA)
                    .attr("opacity", 0.5);
                oldBarsA.transition()
                    .duration(500)
                    .attr("y", yBar(0))
                    .attr("height", 0)
                    .remove();
            }
            if (window.prevBinsB && window.prevColorB && window.changedB) {
                const oldBarsB = gBar.selectAll(".old-bar-B")
                    .data(window.prevBinsB)
                    .enter().append("rect")
                    .attr("class", "old-bar-B")
                    .attr("x", d => xBar(d.x0))
                    .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                    .attr("fill", window.prevColorB)
                    .attr("opacity", 0.5);
                if (window.plotBNegativeX) {
                    // Start at negative position, shrink upward to center axis
                    oldBarsB
                        .attr("y", d => yBar(0))
                        .attr("height", d => yBar(-d.length) - yBar(0))
                        .transition()
                        .duration(500)
                        .attr("height", 0)
                        .remove();
                } else {
                    // Default positive behavior
                    oldBarsB
                        .attr("y", d => yBar(d.length))
                        .attr("height", d => yBar(0) - yBar(d.length))
                        .transition()
                        .duration(500)
                        .attr("y", yBar(0))
                        .attr("height", 0)
                        .remove();
                }
            }

            // Bars for datasetA (animate only if changed)
            const barsA = gBar.selectAll(".bar-A")
                .data(binsA)
                .enter().append("rect")
                .attr("class", "bar-A")
                .attr("x", d => xBar(d.x0))
                .attr("y", yBar(0))
                .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                .attr("height", 0)
                .attr("fill", colorA)
                .attr("opacity", 0.5)
                .style("cursor", "pointer")
                .on("click", function(event, d) {
                    if (!window.selectedBinsA) window.selectedBinsA = {};
                    const binKey = `${d.x0}-${d.x1}`;
                    window.selectedBinsA[binKey] = !window.selectedBinsA[binKey];
                    highlightScatterPoints('A', binsA, window.selectedBinsA, datasetA, '#scatter-A');
                    updateBarOutlines('A', binsA, window.selectedBinsA, gBar, colorA, xBar, yBar);
                });
            if (window.changedA) {
                barsA.transition()
                    .delay(500)
                    .duration(800)
                    .attr("y", d => yBar(d.length))
                    .attr("height", d => yBar(0) - yBar(d.length));
            } else {
                barsA.attr("y", d => yBar(d.length))
                    .attr("height", d => yBar(0) - yBar(d.length));
            }

            // Bars for datasetB (animate only if changed)
            const barsB = gBar.selectAll(".bar-B")
                .data(binsB)
                .enter().append("rect")
                .attr("class", "bar-B")
                .attr("x", d => xBar(d.x0))
                .attr("y", yBar(0))
                .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                .attr("height", 0)
                .attr("fill", colorB)
                .attr("opacity", 0.5)
                .style("cursor", "pointer")
                .on("click", function(event, d) {
                    if (!window.selectedBinsB) window.selectedBinsB = {};
                    const binKey = `${d.x0}-${d.x1}`;
                    window.selectedBinsB[binKey] = !window.selectedBinsB[binKey];
                    highlightScatterPoints('B', binsB, window.selectedBinsB, datasetB, '#scatter-B');
                    updateBarOutlines('B', binsB, window.selectedBinsB, gBar, colorB, xBar, yBar);
                });
        // Draw gold outlines for selected bars (no fill)
        function updateBarOutlines(which, bins, selectedBins, gBar, color, xBar, yBar) {
            // Remove previous outlines
            gBar.selectAll('.bar-' + which + '-outline').remove();
            Object.entries(selectedBins).forEach(([key, val]) => {
                if (val) {
                    const [x0, x1] = key.split('-').map(Number);
                    const bin = bins.find(b => b.x0 === x0 && b.x1 === x1);
                    if (bin) {
                        gBar.append('rect')
                            .attr('class', 'bar-' + which + '-outline')
                            .attr('x', xBar(bin.x0))
                            .attr('y', yBar(which === 'B' && window.plotBNegativeX ? 0 : bin.length))
                            .attr('width', xBar(bin.x1) - xBar(bin.x0) - 2)
                            .attr('height', which === 'B' && window.plotBNegativeX ? (yBar(-bin.length) - yBar(0)) : (yBar(0) - yBar(bin.length)))
                            .attr('fill', 'none')
                            .attr('stroke', '#ffd700')
                            .attr('stroke-width', 3);
                    }
                }
            });
        }
            if (window.plotBNegativeX) {
                if (window.changedB) {
                    barsB.transition()
                        .delay(500)
                        .duration(800)
                        .attr("y", yBar(0))
                        .attr("height", d => yBar(-d.length) - yBar(0));
                } else {
                    barsB.attr("y", yBar(0))
                        .attr("height", d => yBar(-d.length) - yBar(0));
                }
            } else {
                if (window.changedB) {
                    barsB.transition()
                        .delay(500)
                        .duration(800)
                        .attr("y", d => yBar(d.length))
                        .attr("height", d => yBar(0) - yBar(d.length));
                } else {
                    barsB.attr("y", d => yBar(d.length))
                        .attr("height", d => yBar(0) - yBar(d.length));
                }
            }
        // Highlight scatterplot points based on selected bins
        function highlightScatterPoints(which, bins, selectedBins, dataset, scatterSelector) {
            // Find selected bin ranges
            const selectedRanges = Object.entries(selectedBins)
                .filter(([key, val]) => val)
                .map(([key]) => {
                    const [x0, x1] = key.split('-').map(Number);
                    return {x0, x1};
                });
            // Select scatterplot circles
            const svg = d3.select(scatterSelector + ' svg');
            svg.selectAll('circle')
                .attr('stroke', null)
                .attr('stroke-width', null)
                .attr('opacity', 0.7);
            if (selectedRanges.length === 0) return;
            svg.selectAll('circle')
                .each(function(d) {
                    const inBin = selectedRanges.some(r => d.x >= r.x0 && d.x < r.x1);
                    if (inBin) {
                        d3.select(this)
                            .attr('stroke', '#ffd700')
                            .attr('stroke-width', 2)
                            .attr('opacity', 1);
                    }
                });
        }

            // Store current bins/colors for next update
            window.prevBinsA = binsA;
            window.prevColorA = colorA;
            window.prevBinsB = binsB;
            window.prevColorB = colorB;

            // Helper to darken color
            function darkenColor(hex, factor=0.6) {
                // Convert hex to RGB, then scale
                let c = d3.color(hex);
                if (!c) return hex;
                let r = Math.floor(c.r * factor);
                let g = Math.floor(c.g * factor);
                let b = Math.floor(c.b * factor);
                return `rgb(${r},${g},${b})`;
            }

            // Legend in top-right of plot area
            const legend = gBar.append("g").attr("transform", `translate(${plotWidthBar - 140},0)`);
            legend.append("rect").attr("x", 0).attr("y", 0).attr("width", 18).attr("height", 18).attr("fill", colorA).attr("opacity", 0.5);
            legend.append("text").attr("x", 24).attr("y", 14).text(nameA).style("font-size", "14px");
            legend.append("rect").attr("x", 0).attr("y", 24).attr("width", 18).attr("height", 18).attr("fill", colorB).attr("opacity", 0.5);
            legend.append("text").attr("x", 24).attr("y", 38).text(nameB).style("font-size", "14px");
            // Mean lines legend
            legend.append("line")
                .attr("x1", 0).attr("x2", 18)
                .attr("y1", 54).attr("y2", 54)
                .attr("stroke", darkenColor(colorA))
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "6,3");
            legend.append("text")
                .attr("x", 24).attr("y", 58)
                .text(`Mean ${nameA}`)
                .style("font-size", "13px")
                .attr("fill", darkenColor(colorA));
            legend.append("line")
                .attr("x1", 0).attr("x2", 18)
                .attr("y1", 74).attr("y2", 74)
                .attr("stroke", darkenColor(colorB))
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "6,3");
            legend.append("text")
                .attr("x", 24).attr("y", 78)
                .text(`Mean ${nameB}`)
                .style("font-size", "13px")
                .attr("fill", darkenColor(colorB));

            // Store previous mean/std lines for animation
            if (!window.prevMeanStdA) window.prevMeanStdA = null;
            if (!window.prevMeanStdB) window.prevMeanStdB = null;
            // Animate removal of old lines for changed dataset only
            function animateOldLines(lines, direction, color) {
                lines.forEach(line => {
                    const {x, y1, y2, stroke, strokeWidth, dasharray, type} = line;
                    const l = gBar.append("line")
                        .attr("x1", x)
                        .attr("x2", x)
                        .attr("y1", y1)
                        .attr("y2", y2)
                        .attr("stroke", stroke)
                        .attr("stroke-width", strokeWidth)
                        .attr("stroke-dasharray", dasharray);
                    l.transition()
                        .duration(500)
                        .attr("y2", yBar(0))
                        .attr("y1", yBar(0))
                        .remove();
                });
            }

            // Compute current mean/std lines for A
            const meanA = d3.mean(datasetA, d => d.x);
            const stdA = d3.deviation(datasetA, d => d.x);
            let meanStdLinesA = [];
            meanStdLinesA.push({
                x: xBar(meanA), y1: yBar(0), y2: yBar(globalMaxBinCount), stroke: darkenColor(colorA), strokeWidth: 3, dasharray: "6,3", type: "mean"
            });
            if (stdA) {
                meanStdLinesA.push({
                    x: xBar(meanA - stdA), y1: yBar(0), y2: yBar(globalMaxBinCount), stroke: darkenColor(colorA, 0.8), strokeWidth: 2, dasharray: "2,2", type: "std"
                });
                meanStdLinesA.push({
                    x: xBar(meanA + stdA), y1: yBar(0), y2: yBar(globalMaxBinCount), stroke: darkenColor(colorA, 0.8), strokeWidth: 2, dasharray: "2,2", type: "std"
                });
            }
            // Compute current mean/std lines for B
            const meanB = d3.mean(datasetB, d => d.x);
            const stdB = d3.deviation(datasetB, d => d.x);
            let meanStdLinesB = [];
            if (window.plotBNegativeX) {
                meanStdLinesB.push({
                    x: xBar(meanB), y1: yBar(0), y2: yBar(-globalMaxBinCount), stroke: darkenColor(colorB), strokeWidth: 3, dasharray: "6,3", type: "mean"
                });
                if (stdB) {
                    meanStdLinesB.push({
                        x: xBar(meanB - stdB), y1: yBar(0), y2: yBar(-globalMaxBinCount), stroke: darkenColor(colorB, 0.8), strokeWidth: 2, dasharray: "2,2", type: "std"
                    });
                    meanStdLinesB.push({
                        x: xBar(meanB + stdB), y1: yBar(0), y2: yBar(-globalMaxBinCount), stroke: darkenColor(colorB, 0.8), strokeWidth: 2, dasharray: "2,2", type: "std"
                    });
                }
            } else {
                meanStdLinesB.push({
                    x: xBar(meanB), y1: yBar(0), y2: yBar(globalMaxBinCount), stroke: darkenColor(colorB), strokeWidth: 3, dasharray: "6,3", type: "mean"
                });
                if (stdB) {
                    meanStdLinesB.push({
                        x: xBar(meanB - stdB), y1: yBar(0), y2: yBar(globalMaxBinCount), stroke: darkenColor(colorB, 0.8), strokeWidth: 2, dasharray: "2,2", type: "std"
                    });
                    meanStdLinesB.push({
                        x: xBar(meanB + stdB), y1: yBar(0), y2: yBar(globalMaxBinCount), stroke: darkenColor(colorB, 0.8), strokeWidth: 2, dasharray: "2,2", type: "std"
                    });
                }
            }

            // Animate removal of old lines for changed dataset only
            if (window.prevMeanStdA && window.changedA) {
                animateOldLines(window.prevMeanStdA, "A", window.prevColorA);
            }
            if (window.prevMeanStdB && window.changedB) {
                animateOldLines(window.prevMeanStdB, "B", window.prevColorB);
            }

            // Draw new lines only for changed dataset, keep unchanged
            if (window.changedA || window.prevMeanStdA === null) {
                meanStdLinesA.forEach(line => {
                    gBar.append("line")
                        .attr("x1", line.x)
                        .attr("x2", line.x)
                        .attr("y1", yBar(0))
                        .attr("y2", yBar(0))
                        .attr("stroke", line.stroke)
                        .attr("stroke-width", line.strokeWidth)
                        .attr("stroke-dasharray", line.dasharray)
                        .transition()
                        .duration(800)
                        .attr("y2", line.y2);
                });
                // Mean text label
                gBar.append("text")
                    .attr("x", xBar(meanA) + 4)
                    .attr("y", yBar(globalMaxBinCount) + 15)
                    .attr("fill", darkenColor(colorA))
                    .style("font-size", "13px");
            } else if (window.prevMeanStdA) {
                // Redraw previous lines for unchanged dataset
                window.prevMeanStdA.forEach(line => {
                    gBar.append("line")
                        .attr("x1", line.x)
                        .attr("x2", line.x)
                        .attr("y1", line.y1)
                        .attr("y2", line.y2)
                        .attr("stroke", line.stroke)
                        .attr("stroke-width", line.strokeWidth)
                        .attr("stroke-dasharray", line.dasharray);
                });
                gBar.append("text")
                    .attr("x", window.prevMeanStdA[0].x + 4)
                    .attr("y", yBar(globalMaxBinCount) + 15)
                    .attr("fill", darkenColor(colorA))
                    .style("font-size", "13px");
            }

            if (window.changedB || window.prevMeanStdB === null) {
                meanStdLinesB.forEach(line => {
                    gBar.append("line")
                        .attr("x1", line.x)
                        .attr("x2", line.x)
                        .attr("y1", yBar(0))
                        .attr("y2", yBar(0))
                        .attr("stroke", line.stroke)
                        .attr("stroke-width", line.strokeWidth)
                        .attr("stroke-dasharray", line.dasharray)
                        .transition()
                        .duration(800)
                        .attr("y2", line.y2);
                });
                gBar.append("text")
                    .attr("x", xBar(meanB) + 4)
                    .attr("y", window.plotBNegativeX ? (yBar(-globalMaxBinCount) - 5) : (yBar(globalMaxBinCount) + 15))
                    .attr("fill", darkenColor(colorB))
                    .style("font-size", "13px");
            } else if (window.prevMeanStdB) {
                window.prevMeanStdB.forEach(line => {
                    gBar.append("line")
                        .attr("x1", line.x)
                        .attr("x2", line.x)
                        .attr("y1", line.y1)
                        .attr("y2", line.y2)
                        .attr("stroke", line.stroke)
                        .attr("stroke-width", line.strokeWidth)
                        .attr("stroke-dasharray", line.dasharray);
                });
                gBar.append("text")
                    .attr("x", window.prevMeanStdB[0].x + 4)
                    .attr("y", window.plotBNegativeX ? (yBar(-globalMaxBinCount) - 5) : (yBar(globalMaxBinCount) + 15))
                    .attr("fill", darkenColor(colorB))
                    .style("font-size", "13px");
            }

            // Store current mean/std lines for next update
            window.prevMeanStdA = meanStdLinesA;
            window.prevMeanStdB = meanStdLinesB;
            window.prevColorA = colorA;
            window.prevColorB = colorB;

            // Always redraw outlines for selected bins after bars are drawn
            updateBarOutlines('A', binsA, window.selectedBinsA || {}, gBar, colorA, xBar, yBar);
            updateBarOutlines('B', binsB, window.selectedBinsB || {}, gBar, colorB, xBar, yBar);
        }

        /* ==========================================
           PLOT UPDATE & COORDINATION FUNCTIONS
        ========================================== */
        // Update all plots when dataset selection changes
        function updatePlots() {
            // Only reset highlights when dataset is changed, not when toggling orientation
            if (typeof window.selectedBinsA === 'undefined') window.selectedBinsA = {};
            if (typeof window.selectedBinsB === 'undefined') window.selectedBinsB = {};
            // Detect dataset change
            const nameA = d3.select("#datasetA").property("value");
            const nameB = d3.select("#datasetB").property("value");
            if (window.lastScatterA !== nameA) window.selectedBinsA = {};
            if (window.lastScatterB !== nameB) window.selectedBinsB = {};
            // No need to redraw outlines here; handled in drawSuperpositionBar
                const idxA = datasetNames.indexOf(nameA);
                const idxB = datasetNames.indexOf(nameB);
                const colorA = getColor(idxA);
                const colorB = getColor(idxB);
                const datasetA = data.filter(d => d.dataset === nameA).map(d => ({x: +d.x, y: +d.y}));
                const datasetB = data.filter(d => d.dataset === nameB).map(d => ({x: +d.x, y: +d.y}));

                // Track last selected values
                if (typeof window.lastScatterA === 'undefined') window.lastScatterA = null;
                if (typeof window.lastScatterB === 'undefined') window.lastScatterB = null;

                // Only update the changed scatterplot
                const currentA = nameA;
                const currentB = nameB;
                const changedA = window.lastScatterA !== currentA;
                const changedB = window.lastScatterB !== currentB;
                window.changedA = changedA;
                window.changedB = changedB;

                // Initial load: both null, draw both
                if (window.lastScatterA === null && window.lastScatterB === null) {
                    window.scatterDoneCallback = function() {
                        if (!window._scatterCount) window._scatterCount = 0;
                        window._scatterCount++;
                        if (window._scatterCount === 2) {
                            drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                            window._scatterCount = 0;
                        }
                    };
                    drawScatter("#scatter-A", datasetA, colorA);
                    drawScatter("#scatter-B", datasetB, colorB);
                } else if (changedA) {
                    window.scatterDoneCallback = function() {
                        drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                    };
                    drawScatter("#scatter-A", datasetA, colorA);
                } else if (changedB) {
                    window.scatterDoneCallback = function() {
                        drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                    };
                    drawScatter("#scatter-B", datasetB, colorB);
                } else {
                    // No change, just update bar chart
                    drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                }

                // Always update titles
                d3.select("#title-A").text(`Scatterplot: ${nameA}`);
                d3.select("#title-B").text(`Scatterplot: ${nameB}`);
                d3.select("#title-superposition").text(`Superposition: X Distribution (${nameA} vs ${nameB})`);

                // Update last selected
                window.lastScatterA = currentA;
                window.lastScatterB = currentB;
        }

        // Initialize visualizations on page load
        updatePlots();

        /* ==========================================
           EVENT LISTENERS & UI INTERACTIONS
        ========================================== */
        // Dataset selection change handlers
        d3.select("#datasetA").on("change", updatePlots);
        d3.select("#datasetB").on("change", updatePlots);

        // Toggle button for positive/negative bar chart display
        d3.select("#toggle-negative-x").on("click", function() {
            window.plotBNegativeX = !window.plotBNegativeX;
            d3.select(this).text(window.plotBNegativeX ? "Change B Plot to Positive" : "Change B Plot to Negative");
            updatePlots();
        });
    });

    /* ==========================================
       NAVIGATION MENU FUNCTIONALITY
    ========================================== */
    document.addEventListener('DOMContentLoaded', function() {
        const menuToggle = document.getElementById('menuToggle');
        const menuPanel = document.getElementById('menuPanel');
        
        // Toggle navigation menu visibility
        menuToggle.addEventListener('click', function() {
            menuPanel.classList.toggle('show');
        });

        // Load navigation links from pages.json
        fetch('pages.json')
            .then(response => response.json())
            .then(pages => {
                menuPanel.innerHTML = '';
                pages.forEach(page => {
                    const a = document.createElement('a');
                    a.href = page.file;
                    a.textContent = page.name;
                    menuPanel.appendChild(a);
                });
            })
            .catch(err => {
                menuPanel.innerHTML = '<span style="color:#ff8888">Could not load page list.</span>';
            });
    });

    </script>
</body>
</html>