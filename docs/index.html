<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Datasaurus Dozen D3 Visualizations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f9f9f9; }
        h1 { text-align: center; }
        .chart-container { display: flex; gap: 40px; justify-content: center; margin-bottom: 60px; }
        .chart { background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #ccc; padding: 20px; }
        .chart-title { text-align: center; margin-bottom: 10px; font-weight: bold; }
        .superposition { margin: 0 auto; width: 700px; }
    </style>
</head>
<body>
    <h1>Datasaurus Dozen: D3 Visualizations</h1>
    <p>
        All datasets in the Datasaurus Dozen have the same means, standard deviations, and correlations, but vastly different structures.
        Below, two visualization paradigms illustrate these differences: juxtaposition (side-by-side scatterplots) and superposition (overlaid bar chart).
    </p>

    <div style="display: flex; justify-content: center; gap: 40px; margin-bottom: 30px;">
        <div>
            <label for="datasetA">Select Dataset A:</label>
            <select id="datasetA"></select>
        </div>
        <div>
            <label for="datasetB">Select Dataset B:</label>
            <select id="datasetB"></select>
        </div>
    </div>

    <div class="chart-container">
        <div class="chart" id="scatter-A">
            <div class="chart-title" id="title-A">Scatterplot: </div>
            <svg width="300" height="300"></svg>
        </div>
        <div class="chart" id="scatter-B">
            <div class="chart-title" id="title-B">Scatterplot: </div>
            <svg width="300" height="300"></svg>
        </div>
    </div>

    <div class="chart superposition" id="bar-superposition">
        <div class="chart-title" id="title-superposition">Superposition: X Distribution</div>
        <svg width="700" height="300"></svg>
    </div>

    <script>
    // Load CSV data
    d3.csv("data.csv").then(function(data) {
    // Find global min/max for x and y
    const globalX = d3.extent(data, d => +d.x);
    const globalY = d3.extent(data, d => +d.y);
    // Compute global max bin count for histogram y-axis
    const datasetNames = Array.from(new Set(data.map(d => d.dataset)));
    // Restore original bin count
    const bins = d3.bin().domain([0, 100]).thresholds(20);
    let globalMaxBinCount = 0;
    datasetNames.forEach(name => {
        const dataset = data.filter(d => d.dataset === name).map(d => +d.x);
        const binCounts = bins(dataset).map(bin => bin.length);
        const maxCount = d3.max(binCounts);
        if (maxCount > globalMaxBinCount) globalMaxBinCount = maxCount;
    });
        // Get all dataset names
    // datasetNames already declared above
        // Populate dropdowns
        datasetNames.forEach(name => {
            d3.select("#datasetA").append("option").attr("value", name).text(name);
            d3.select("#datasetB").append("option").attr("value", name).text(name);
        });
        // Default selections
        d3.select("#datasetA").property("value", "dino");
        d3.select("#datasetB").property("value", "circle");

        // Color palette
        const colors = ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999", "#1b9e77", "#d95f02", "#7570b3"];
        function getColor(idx) { return colors[idx % colors.length]; }

        // Draw scatterplot with animation
        function drawScatter(selector, dataset, color) {
            const svg = d3.select(selector + " svg");
            svg.selectAll("*").remove();
            const width = +svg.attr("width"), height = +svg.attr("height");
            const margin = {top: 20, right: 20, bottom: 30, left: 30};
            const plotWidth = width - margin.left - margin.right;
            const plotHeight = height - margin.top - margin.bottom;

            // Use global axis limits
            const x = d3.scaleLinear()
                .domain(globalX).nice()
                .range([0, plotWidth]);
            const y = d3.scaleLinear()
                .domain(globalY).nice()
                .range([plotHeight, 0]);

            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

            // Axes
            g.append("g")
                .attr("transform", `translate(0,${plotHeight})`)
                .call(d3.axisBottom(x));
            g.append("g")
                .call(d3.axisLeft(y));

            // Points with sequential animation (one-by-one, faster)
            function animatePoints(points, i, onDone) {
                if (i >= dataset.length) { if (onDone) onDone(); return; }
                points.filter((d, idx) => idx === i)
                    .transition()
                    .duration(60)
                    .attr("r", 3)
                    .attr("opacity", 0.7);
                setTimeout(() => animatePoints(points, i+1, onDone), 10);
            }

            const circles = g.selectAll("circle")
                .data(dataset, (d,i) => i);
            circles.enter()
                .append("circle")
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .attr("r", 0)
                .attr("fill", color)
                .attr("opacity", 0)
                .call(function(points) { animatePoints(points, 0, window.scatterDoneCallback); });
        }

        // Draw animated superposition bar chart
        function drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB) {
            const svgBar = d3.select("#bar-superposition svg");
            svgBar.selectAll("*").remove();
            const widthBar = +svgBar.attr("width"), heightBar = +svgBar.attr("height");
            const marginBar = {top: 20, right: 20, bottom: 30, left: 40};
            const plotWidthBar = widthBar - marginBar.left - marginBar.right;
            const plotHeightBar = heightBar - marginBar.top - marginBar.bottom;

            // Bin x values with updated bin count
            const binsA = bins(datasetA.map(d => d.x));
            const binsB = bins(datasetB.map(d => d.x));

            const xBar = d3.scaleLinear()
                .domain([0, 100])
                .range([0, plotWidthBar]);
            // Use globalMaxBinCount for constant y-axis
            const yBar = d3.scaleLinear()
                .domain([0, globalMaxBinCount])
                .range([plotHeightBar, 0]);

            const gBar = svgBar.append("g").attr("transform", `translate(${marginBar.left},${marginBar.top})`);

            // Axes
            gBar.append("g")
                .attr("transform", `translate(0,${plotHeightBar})`)
                .call(d3.axisBottom(xBar));
            gBar.append("g")
                .call(d3.axisLeft(yBar));

            // Animate only the bars for the changed dataset
            if (window.prevBinsA && window.prevColorA && window.changedA) {
                const oldBarsA = gBar.selectAll(".old-bar-A")
                    .data(window.prevBinsA)
                    .enter().append("rect")
                    .attr("class", "old-bar-A")
                    .attr("x", d => xBar(d.x0))
                    .attr("y", d => yBar(d.length))
                    .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                    .attr("height", d => plotHeightBar - yBar(d.length))
                    .attr("fill", window.prevColorA)
                    .attr("opacity", 0.5);
                oldBarsA.transition()
                    .duration(500)
                    .attr("y", plotHeightBar)
                    .attr("height", 0)
                    .remove();
            }
            if (window.prevBinsB && window.prevColorB && window.changedB) {
                const oldBarsB = gBar.selectAll(".old-bar-B")
                    .data(window.prevBinsB)
                    .enter().append("rect")
                    .attr("class", "old-bar-B")
                    .attr("x", d => xBar(d.x0) + 2)
                    .attr("y", d => yBar(d.length))
                    .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                    .attr("height", d => plotHeightBar - yBar(d.length))
                    .attr("fill", window.prevColorB)
                    .attr("opacity", 0.5);
                oldBarsB.transition()
                    .duration(500)
                    .attr("y", plotHeightBar)
                    .attr("height", 0)
                    .remove();
            }

            // Bars for datasetA (animate only if changed)
            const barsA = gBar.selectAll(".bar-A")
                .data(binsA)
                .enter().append("rect")
                .attr("class", "bar-A")
                .attr("x", d => xBar(d.x0))
                .attr("y", plotHeightBar)
                .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                .attr("height", 0)
                .attr("fill", colorA)
                .attr("opacity", 0.5);
            if (window.changedA) {
                barsA.transition()
                    .delay(500)
                    .duration(800)
                    .attr("y", d => yBar(d.length))
                    .attr("height", d => plotHeightBar - yBar(d.length));
            } else {
                barsA.attr("y", d => yBar(d.length))
                    .attr("height", d => plotHeightBar - yBar(d.length));
            }

            // Bars for datasetB (animate only if changed)
            const barsB = gBar.selectAll(".bar-B")
                .data(binsB)
                .enter().append("rect")
                .attr("class", "bar-B")
                .attr("x", d => xBar(d.x0) + 2)
                .attr("y", plotHeightBar)
                .attr("width", d => xBar(d.x1) - xBar(d.x0) - 2)
                .attr("height", 0)
                .attr("fill", colorB)
                .attr("opacity", 0.5);
            if (window.changedB) {
                barsB.transition()
                    .delay(500)
                    .duration(800)
                    .attr("y", d => yBar(d.length))
                    .attr("height", d => plotHeightBar - yBar(d.length));
            } else {
                barsB.attr("y", d => yBar(d.length))
                    .attr("height", d => plotHeightBar - yBar(d.length));
            }

            // Store current bins/colors for next update
            window.prevBinsA = binsA;
            window.prevColorA = colorA;
            window.prevBinsB = binsB;
            window.prevColorB = colorB;

            // Helper to darken color
            function darkenColor(hex, factor=0.6) {
                // Convert hex to RGB, then scale
                let c = d3.color(hex);
                if (!c) return hex;
                let r = Math.floor(c.r * factor);
                let g = Math.floor(c.g * factor);
                let b = Math.floor(c.b * factor);
                return `rgb(${r},${g},${b})`;
            }

            // Legend in top-right of plot area
            const legend = gBar.append("g").attr("transform", `translate(${plotWidthBar - 140},0)`);
            legend.append("rect").attr("x", 0).attr("y", 0).attr("width", 18).attr("height", 18).attr("fill", colorA).attr("opacity", 0.5);
            legend.append("text").attr("x", 24).attr("y", 14).text(nameA).style("font-size", "14px");
            legend.append("rect").attr("x", 0).attr("y", 24).attr("width", 18).attr("height", 18).attr("fill", colorB).attr("opacity", 0.5);
            legend.append("text").attr("x", 24).attr("y", 38).text(nameB).style("font-size", "14px");
            // Mean lines legend
            legend.append("line")
                .attr("x1", 0).attr("x2", 18)
                .attr("y1", 54).attr("y2", 54)
                .attr("stroke", darkenColor(colorA))
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "6,3");
            legend.append("text")
                .attr("x", 24).attr("y", 58)
                .text(`Mean ${nameA}`)
                .style("font-size", "13px")
                .attr("fill", darkenColor(colorA));
            legend.append("line")
                .attr("x1", 0).attr("x2", 18)
                .attr("y1", 74).attr("y2", 74)
                .attr("stroke", darkenColor(colorB))
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "6,3");
            legend.append("text")
                .attr("x", 24).attr("y", 78)
                .text(`Mean ${nameB}`)
                .style("font-size", "13px")
                .attr("fill", darkenColor(colorB));

            // Mean vertical lines
            const meanA = d3.mean(datasetA, d => d.x);
            const meanB = d3.mean(datasetB, d => d.x);
            // Line for datasetA mean
            gBar.append("line")
                .attr("x1", xBar(meanA))
                .attr("x2", xBar(meanA))
                .attr("y1", plotHeightBar)
                .attr("y2", plotHeightBar)
                .attr("stroke", darkenColor(colorA))
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "6,3")
                .transition()
                .duration(800)
                .attr("y2", 0);
            gBar.append("text")
                .attr("x", xBar(meanA) + 4)
                .attr("y", 15)
                .attr("fill", darkenColor(colorA))
                .style("font-size", "13px");

            // Line for datasetB mean
            gBar.append("line")
                .attr("x1", xBar(meanB))
                .attr("x2", xBar(meanB))
                .attr("y1", plotHeightBar)
                .attr("y2", plotHeightBar)
                .attr("stroke", darkenColor(colorB))
                .attr("stroke-width", 3)
                .attr("stroke-dasharray", "6,3")
                .transition()
                .duration(800)
                .attr("y2", 0);
            gBar.append("text")
                .attr("x", xBar(meanB) + 4)
                .attr("y", 32)
                .attr("fill", darkenColor(colorB))
                .style("font-size", "13px");
        }

        // Update all plots
        function updatePlots() {
            const nameA = d3.select("#datasetA").property("value");
            const nameB = d3.select("#datasetB").property("value");
                const idxA = datasetNames.indexOf(nameA);
                const idxB = datasetNames.indexOf(nameB);
                const colorA = getColor(idxA);
                const colorB = getColor(idxB);
                const datasetA = data.filter(d => d.dataset === nameA).map(d => ({x: +d.x, y: +d.y}));
                const datasetB = data.filter(d => d.dataset === nameB).map(d => ({x: +d.x, y: +d.y}));

                // Track last selected values
                if (typeof window.lastScatterA === 'undefined') window.lastScatterA = null;
                if (typeof window.lastScatterB === 'undefined') window.lastScatterB = null;

                // Only update the changed scatterplot
                const currentA = nameA;
                const currentB = nameB;
                const changedA = window.lastScatterA !== currentA;
                const changedB = window.lastScatterB !== currentB;
                window.changedA = changedA;
                window.changedB = changedB;

                // Initial load: both null, draw both
                if (window.lastScatterA === null && window.lastScatterB === null) {
                    window.scatterDoneCallback = function() {
                        if (!window._scatterCount) window._scatterCount = 0;
                        window._scatterCount++;
                        if (window._scatterCount === 2) {
                            drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                            window._scatterCount = 0;
                        }
                    };
                    drawScatter("#scatter-A", datasetA, colorA);
                    drawScatter("#scatter-B", datasetB, colorB);
                } else if (changedA) {
                    window.scatterDoneCallback = function() {
                        drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                    };
                    drawScatter("#scatter-A", datasetA, colorA);
                } else if (changedB) {
                    window.scatterDoneCallback = function() {
                        drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                    };
                    drawScatter("#scatter-B", datasetB, colorB);
                } else {
                    // No change, just update bar chart
                    drawSuperpositionBar(datasetA, datasetB, nameA, nameB, colorA, colorB);
                }

                // Always update titles
                d3.select("#title-A").text(`Scatterplot: ${nameA}`);
                d3.select("#title-B").text(`Scatterplot: ${nameB}`);
                d3.select("#title-superposition").text(`Superposition: X Distribution (${nameA} vs ${nameB})`);

                // Update last selected
                window.lastScatterA = currentA;
                window.lastScatterB = currentB;
        }

        // Initial plot
        updatePlots();

        // Event listeners
        d3.select("#datasetA").on("change", updatePlots);
        d3.select("#datasetB").on("change", updatePlots);
    });
    </script>
</body>
</html>